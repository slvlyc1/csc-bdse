- **Q**: Нужно ли глубоко знать/изучать Spring Boot?
- **A**: Нет, предполагается что задания будут решены без существенного использования фреймворка, его применение 
просто сокращает кодовую базу (HTTP API, клиент). Цель изучить не Spring Boot, а принципы построения хранилищ больших данных.


- **Q**: Почему метод `Set<NodeInfo> getInfo()` возвращает информацию по нескольким нодам, когда в первом задании 
предполагается реализовать одну?
- **A**: Одна нода в первом задании, в нем организуется основа для последующего наращивания функциональности. Далее, 
когда из нод будет собираться распределенная система, информация будет возвращаться обо всем кластере.


- **Q**: Что предполагается в качестве реализации метода `action(String node, NodeAction action)`?
- **A**: Любой простой способ обработки команд остановки и поднятия ноды: влияние на связь с подлежащей СУБД, 
остановка/поднятие контейнера СУБД, моделирование неполадок.


- **Q**: В процессе запуска тестов с контейнерами возникает ошибка "Could not start container org.testcontainers
.containers.ContainerLaunchException: Timed out waiting for container port to open", что делать?
- **A**: В тестах указывается таймаут в 30 секунд как максимальное время запуска контейнера. Предполагается что этого
 достаточно для инициализации и запуска. Если есть разумные причины увеличить таймаут, это можно сделать, иначе 
 следует прооптимизировать процесс инициализации - ускорить его.  

- **Q**: Во втором задании есть упоминание о нескольких серверах приложения. Правда ли, что может быть запущено  
несколько серверов приложения? Если да, правда ли, что при этом kv-node одна на всех? Требуется ли в честь этого  
реализовать транзакционность?
- **A**: да, предполагается что может работать, как минимум, PhoneBook 1.0 и PhoneBook 1.1 одновременно, при этом 
используется один инстанс kv-node. Транзакционность реализовывать не нужно: предполагается что операция с одним ключом в 
 kv-node атомарна. Если сохраняются две записи (в PhoneBook 1.1) и зафейлилась одна из них, то функциональность отката 
 необязательна - достаточно вернуть клиенту приложения ошибку.